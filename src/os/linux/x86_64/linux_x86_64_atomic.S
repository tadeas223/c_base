# generated by ai
# i cant write assembly :(

## .global os_atomic_u8_compare_exchange
## .type os_atomic_u8_compare_exchange, @function
## os_atomic_u8_compare_exchange:
##     movb (%rsi), %al          # load expected
##     lock cmpxchgb %dl, (%rdi) # compare and swap
##     sete %al
##     movzbl %al, %eax          # zero-extend for return value
##     ret
## 
## .global os_atomic_u8_fetch_sub
## .type os_atomic_u8_fetch_sub, @function
## os_atomic_u8_fetch_sub:
##     movb %sil, %al
##     negb %al
##     lock xaddb %al, (%rdi)
##     ret
## 
## .global os_atomic_u8_store
## .type os_atomic_u8_store, @function
## os_atomic_u8_store:
##     movb %sil, %al
##     lock xchgb %al, (%rdi)
##     ret
## 
.global os_atomic_u32_compare_exchange
.type   os_atomic_u32_compare_exchange, @function
# u32 os_atomic_u32_compare_exchange(u32 *ptr,
#                                           u32 *expected,
#                                           u32 desired)
os_atomic_u32_compare_exchange:
    movl    (%rsi), %eax           # load *expected into EAX
    lock cmpxchgl %edx, (%rdi)     # if (*ptr == EAX) then *ptr = EDX else EAX := *ptr
    je      1f                     # jump if equal (swap succeeded)

    # failed: store observed value (EAX) into *expected
    movl    %eax, (%rsi)
    xorl    %eax, %eax             # return 0
    ret

1:  movl    $1, %eax               # return 1 (success)
    ret

# void os_atomic_u32_store(u32 *addr, u32 val);
# Arguments (SysV ABI, Linux):
#   addr in %rdi
#   val  in %esi

.global os_atomic_u32_store
.type os_atomic_u32_store, @function
os_atomic_u32_store:
    movl %esi, (%rdi)       # store 32-bit value
    mfence                  # full memory barrier
    ret

.global os_atomic_u32_load
.type os_atomic_u32_load, @function

# u32 os_atomic_u32_load(u32 *ptr)
os_atomic_u32_load:
    # rdi = ptr
    movl (%rdi), %eax   # Load 32-bit value from memory
    mfence              # Full memory fence for sequential consistency
    ret

